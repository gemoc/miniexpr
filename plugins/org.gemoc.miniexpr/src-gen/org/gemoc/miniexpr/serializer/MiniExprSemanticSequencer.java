/*
 * generated by Xtext 2.22.0
 */
package org.gemoc.miniexpr.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.gemoc.miniexpr.miniExpr.And;
import org.gemoc.miniexpr.miniExpr.ArrayRef;
import org.gemoc.miniexpr.miniExpr.ArraySize;
import org.gemoc.miniexpr.miniExpr.BoolConstant;
import org.gemoc.miniexpr.miniExpr.Comparison;
import org.gemoc.miniexpr.miniExpr.ContractedIf;
import org.gemoc.miniexpr.miniExpr.Div;
import org.gemoc.miniexpr.miniExpr.Equality;
import org.gemoc.miniexpr.miniExpr.MiniExprPackage;
import org.gemoc.miniexpr.miniExpr.Minus;
import org.gemoc.miniexpr.miniExpr.Model;
import org.gemoc.miniexpr.miniExpr.Modulo;
import org.gemoc.miniexpr.miniExpr.Mul;
import org.gemoc.miniexpr.miniExpr.Not;
import org.gemoc.miniexpr.miniExpr.NumberConstant;
import org.gemoc.miniexpr.miniExpr.Or;
import org.gemoc.miniexpr.miniExpr.Parenthesis;
import org.gemoc.miniexpr.miniExpr.Plus;
import org.gemoc.miniexpr.miniExpr.PropertyRef;
import org.gemoc.miniexpr.miniExpr.SimpleVarRef;
import org.gemoc.miniexpr.miniExpr.UnaryMinus;
import org.gemoc.miniexpr.miniExpr.VectorConstant;
import org.gemoc.miniexpr.services.MiniExprGrammarAccess;

@SuppressWarnings("all")
public class MiniExprSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MiniExprGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MiniExprPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MiniExprPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case MiniExprPackage.ARRAY_REF:
				sequence_Ref(context, (ArrayRef) semanticObject); 
				return; 
			case MiniExprPackage.ARRAY_SIZE:
				sequence_ArraySize(context, (ArraySize) semanticObject); 
				return; 
			case MiniExprPackage.BOOL_CONSTANT:
				sequence_Atomic(context, (BoolConstant) semanticObject); 
				return; 
			case MiniExprPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case MiniExprPackage.CONTRACTED_IF:
				sequence_ContractedIf(context, (ContractedIf) semanticObject); 
				return; 
			case MiniExprPackage.DIV:
				sequence_MulOrDiv(context, (Div) semanticObject); 
				return; 
			case MiniExprPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case MiniExprPackage.MINUS:
				sequence_PlusOrMinus(context, (Minus) semanticObject); 
				return; 
			case MiniExprPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MiniExprPackage.MODULO:
				sequence_Modulo(context, (Modulo) semanticObject); 
				return; 
			case MiniExprPackage.MUL:
				sequence_MulOrDiv(context, (Mul) semanticObject); 
				return; 
			case MiniExprPackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case MiniExprPackage.NUMBER_CONSTANT:
				sequence_Atomic(context, (NumberConstant) semanticObject); 
				return; 
			case MiniExprPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case MiniExprPackage.PARENTHESIS:
				sequence_Primary(context, (Parenthesis) semanticObject); 
				return; 
			case MiniExprPackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case MiniExprPackage.PROPERTY_REF:
				sequence_Ref(context, (PropertyRef) semanticObject); 
				return; 
			case MiniExprPackage.SIMPLE_VAR_REF:
				sequence_SimpleVarRef(context, (SimpleVarRef) semanticObject); 
				return; 
			case MiniExprPackage.UNARY_MINUS:
				sequence_Primary(context, (UnaryMinus) semanticObject); 
				return; 
			case MiniExprPackage.VECTOR_CONSTANT:
				sequence_Atomic(context, (VectorConstant) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *     ContractedIf returns And
	 *     ContractedIf.ContractedIf_1_0 returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 op='&&' right=Equality)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.AND__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.AND__OP));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getOpAmpersandAmpersandKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ArraySize
	 *     ContractedIf returns ArraySize
	 *     ContractedIf.ContractedIf_1_0 returns ArraySize
	 *     Or returns ArraySize
	 *     Or.Or_1_0 returns ArraySize
	 *     And returns ArraySize
	 *     And.And_1_0 returns ArraySize
	 *     Equality returns ArraySize
	 *     Equality.Equality_1_0 returns ArraySize
	 *     Comparison returns ArraySize
	 *     Comparison.Comparison_1_0 returns ArraySize
	 *     PlusOrMinus returns ArraySize
	 *     PlusOrMinus.Plus_1_0_0_0 returns ArraySize
	 *     PlusOrMinus.Minus_1_0_1_0 returns ArraySize
	 *     MulOrDiv returns ArraySize
	 *     MulOrDiv.Mul_1_0_0_0 returns ArraySize
	 *     MulOrDiv.Div_1_0_1_0 returns ArraySize
	 *     Modulo returns ArraySize
	 *     Modulo.Modulo_1_0 returns ArraySize
	 *     Primary returns ArraySize
	 *     Atomic returns ArraySize
	 *     ArraySize returns ArraySize
	 *
	 * Constraint:
	 *     array=Ref
	 */
	protected void sequence_ArraySize(ISerializationContext context, ArraySize semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.ARRAY_SIZE__ARRAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.ARRAY_SIZE__ARRAY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArraySizeAccess().getArrayRefParserRuleCall_1_0(), semanticObject.getArray());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BoolConstant
	 *     ContractedIf returns BoolConstant
	 *     ContractedIf.ContractedIf_1_0 returns BoolConstant
	 *     Or returns BoolConstant
	 *     Or.Or_1_0 returns BoolConstant
	 *     And returns BoolConstant
	 *     And.And_1_0 returns BoolConstant
	 *     Equality returns BoolConstant
	 *     Equality.Equality_1_0 returns BoolConstant
	 *     Comparison returns BoolConstant
	 *     Comparison.Comparison_1_0 returns BoolConstant
	 *     PlusOrMinus returns BoolConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns BoolConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns BoolConstant
	 *     MulOrDiv returns BoolConstant
	 *     MulOrDiv.Mul_1_0_0_0 returns BoolConstant
	 *     MulOrDiv.Div_1_0_1_0 returns BoolConstant
	 *     Modulo returns BoolConstant
	 *     Modulo.Modulo_1_0 returns BoolConstant
	 *     Primary returns BoolConstant
	 *     Atomic returns BoolConstant
	 *
	 * Constraint:
	 *     value?='true'?
	 */
	protected void sequence_Atomic(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumberConstant
	 *     ContractedIf returns NumberConstant
	 *     ContractedIf.ContractedIf_1_0 returns NumberConstant
	 *     Or returns NumberConstant
	 *     Or.Or_1_0 returns NumberConstant
	 *     And returns NumberConstant
	 *     And.And_1_0 returns NumberConstant
	 *     Equality returns NumberConstant
	 *     Equality.Equality_1_0 returns NumberConstant
	 *     Comparison returns NumberConstant
	 *     Comparison.Comparison_1_0 returns NumberConstant
	 *     PlusOrMinus returns NumberConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns NumberConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns NumberConstant
	 *     MulOrDiv returns NumberConstant
	 *     MulOrDiv.Mul_1_0_0_0 returns NumberConstant
	 *     MulOrDiv.Div_1_0_1_0 returns NumberConstant
	 *     Modulo returns NumberConstant
	 *     Modulo.Modulo_1_0 returns NumberConstant
	 *     Primary returns NumberConstant
	 *     Atomic returns NumberConstant
	 *
	 * Constraint:
	 *     value=NUMBER
	 */
	protected void sequence_Atomic(ISerializationContext context, NumberConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.NUMBER_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.NUMBER_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueNUMBERTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VectorConstant
	 *     ContractedIf returns VectorConstant
	 *     ContractedIf.ContractedIf_1_0 returns VectorConstant
	 *     Or returns VectorConstant
	 *     Or.Or_1_0 returns VectorConstant
	 *     And returns VectorConstant
	 *     And.And_1_0 returns VectorConstant
	 *     Equality returns VectorConstant
	 *     Equality.Equality_1_0 returns VectorConstant
	 *     Comparison returns VectorConstant
	 *     Comparison.Comparison_1_0 returns VectorConstant
	 *     PlusOrMinus returns VectorConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns VectorConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns VectorConstant
	 *     MulOrDiv returns VectorConstant
	 *     MulOrDiv.Mul_1_0_0_0 returns VectorConstant
	 *     MulOrDiv.Div_1_0_1_0 returns VectorConstant
	 *     Modulo returns VectorConstant
	 *     Modulo.Modulo_1_0 returns VectorConstant
	 *     Primary returns VectorConstant
	 *     Atomic returns VectorConstant
	 *
	 * Constraint:
	 *     (values+=Expression values+=Expression*)
	 */
	protected void sequence_Atomic(ISerializationContext context, VectorConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparison
	 *     ContractedIf returns Comparison
	 *     ContractedIf.ContractedIf_1_0 returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0 (op='>=' | op='<=' | op='>' | op='<') right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ContractedIf
	 *     ContractedIf returns ContractedIf
	 *     ContractedIf.ContractedIf_1_0 returns ContractedIf
	 *
	 * Constraint:
	 *     (condition=ContractedIf_ContractedIf_1_0 then=Or else=Or)
	 */
	protected void sequence_ContractedIf(ISerializationContext context, ContractedIf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.CONTRACTED_IF__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.CONTRACTED_IF__CONDITION));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.CONTRACTED_IF__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.CONTRACTED_IF__THEN));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.CONTRACTED_IF__ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.CONTRACTED_IF__ELSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContractedIfAccess().getContractedIfConditionAction_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getContractedIfAccess().getThenOrParserRuleCall_1_2_0(), semanticObject.getThen());
		feeder.accept(grammarAccess.getContractedIfAccess().getElseOrParserRuleCall_1_4_0(), semanticObject.getElse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equality
	 *     ContractedIf returns Equality
	 *     ContractedIf.ContractedIf_1_0 returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0 (op='==' | op='!=') right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     expressions+=Expression+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Modulo
	 *     ContractedIf returns Modulo
	 *     ContractedIf.ContractedIf_1_0 returns Modulo
	 *     Or returns Modulo
	 *     Or.Or_1_0 returns Modulo
	 *     And returns Modulo
	 *     And.And_1_0 returns Modulo
	 *     Equality returns Modulo
	 *     Equality.Equality_1_0 returns Modulo
	 *     Comparison returns Modulo
	 *     Comparison.Comparison_1_0 returns Modulo
	 *     PlusOrMinus returns Modulo
	 *     PlusOrMinus.Plus_1_0_0_0 returns Modulo
	 *     PlusOrMinus.Minus_1_0_1_0 returns Modulo
	 *     MulOrDiv returns Modulo
	 *     MulOrDiv.Mul_1_0_0_0 returns Modulo
	 *     MulOrDiv.Div_1_0_1_0 returns Modulo
	 *     Modulo returns Modulo
	 *     Modulo.Modulo_1_0 returns Modulo
	 *
	 * Constraint:
	 *     (left=Modulo_Modulo_1_0 op='%' right=Primary)
	 */
	protected void sequence_Modulo(ISerializationContext context, Modulo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.MODULO__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.MODULO__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.MODULO__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.MODULO__OP));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.MODULO__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.MODULO__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModuloAccess().getModuloLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getModuloAccess().getOpPercentSignKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getModuloAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Div
	 *     ContractedIf returns Div
	 *     ContractedIf.ContractedIf_1_0 returns Div
	 *     Or returns Div
	 *     Or.Or_1_0 returns Div
	 *     And returns Div
	 *     And.And_1_0 returns Div
	 *     Equality returns Div
	 *     Equality.Equality_1_0 returns Div
	 *     Comparison returns Div
	 *     Comparison.Comparison_1_0 returns Div
	 *     PlusOrMinus returns Div
	 *     PlusOrMinus.Plus_1_0_0_0 returns Div
	 *     PlusOrMinus.Minus_1_0_1_0 returns Div
	 *     MulOrDiv returns Div
	 *     MulOrDiv.Mul_1_0_0_0 returns Div
	 *     MulOrDiv.Div_1_0_1_0 returns Div
	 *
	 * Constraint:
	 *     (Left=MulOrDiv_Div_1_0_1_0 op='/' right=Modulo)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.DIV__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.DIV__OP));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulOrDivAccess().getDivLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulOrDivAccess().getOpSolidusKeyword_1_0_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getMulOrDivAccess().getRightModuloParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Mul
	 *     ContractedIf returns Mul
	 *     ContractedIf.ContractedIf_1_0 returns Mul
	 *     Or returns Mul
	 *     Or.Or_1_0 returns Mul
	 *     And returns Mul
	 *     And.And_1_0 returns Mul
	 *     Equality returns Mul
	 *     Equality.Equality_1_0 returns Mul
	 *     Comparison returns Mul
	 *     Comparison.Comparison_1_0 returns Mul
	 *     PlusOrMinus returns Mul
	 *     PlusOrMinus.Plus_1_0_0_0 returns Mul
	 *     PlusOrMinus.Minus_1_0_1_0 returns Mul
	 *     MulOrDiv returns Mul
	 *     MulOrDiv.Mul_1_0_0_0 returns Mul
	 *     MulOrDiv.Div_1_0_1_0 returns Mul
	 *
	 * Constraint:
	 *     (left=MulOrDiv_Mul_1_0_0_0 op='*' right=Modulo)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Mul semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.MUL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.MUL__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.MUL__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.MUL__OP));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.MUL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.MUL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulOrDivAccess().getMulLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulOrDivAccess().getOpAsteriskKeyword_1_0_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getMulOrDivAccess().getRightModuloParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Or
	 *     ContractedIf returns Or
	 *     ContractedIf.ContractedIf_1_0 returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 op='||' right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.OR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.OR__OP));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getOpVerticalLineVerticalLineKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     ContractedIf returns Minus
	 *     ContractedIf.ContractedIf_1_0 returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Equality returns Minus
	 *     Equality.Equality_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparison_1_0 returns Minus
	 *     PlusOrMinus returns Minus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Minus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Minus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Minus_1_0_1_0 op='-' right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.MINUS__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.MINUS__OP));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getOpHyphenMinusKeyword_1_0_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     ContractedIf returns Plus
	 *     ContractedIf.ContractedIf_1_0 returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.Equality_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparison_1_0 returns Plus
	 *     PlusOrMinus returns Plus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Plus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Plus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Plus_1_0_0_0 op='+' right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.PLUS__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.PLUS__OP));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getOpPlusSignKeyword_1_0_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Not
	 *     ContractedIf returns Not
	 *     ContractedIf.ContractedIf_1_0 returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Equality returns Not
	 *     Equality.Equality_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.Comparison_1_0 returns Not
	 *     PlusOrMinus returns Not
	 *     PlusOrMinus.Plus_1_0_0_0 returns Not
	 *     PlusOrMinus.Minus_1_0_1_0 returns Not
	 *     MulOrDiv returns Not
	 *     MulOrDiv.Mul_1_0_0_0 returns Not
	 *     MulOrDiv.Div_1_0_1_0 returns Not
	 *     Modulo returns Not
	 *     Modulo.Modulo_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_2_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Parenthesis
	 *     ContractedIf returns Parenthesis
	 *     ContractedIf.ContractedIf_1_0 returns Parenthesis
	 *     Or returns Parenthesis
	 *     Or.Or_1_0 returns Parenthesis
	 *     And returns Parenthesis
	 *     And.And_1_0 returns Parenthesis
	 *     Equality returns Parenthesis
	 *     Equality.Equality_1_0 returns Parenthesis
	 *     Comparison returns Parenthesis
	 *     Comparison.Comparison_1_0 returns Parenthesis
	 *     PlusOrMinus returns Parenthesis
	 *     PlusOrMinus.Plus_1_0_0_0 returns Parenthesis
	 *     PlusOrMinus.Minus_1_0_1_0 returns Parenthesis
	 *     MulOrDiv returns Parenthesis
	 *     MulOrDiv.Mul_1_0_0_0 returns Parenthesis
	 *     MulOrDiv.Div_1_0_1_0 returns Parenthesis
	 *     Modulo returns Parenthesis
	 *     Modulo.Modulo_1_0 returns Parenthesis
	 *     Primary returns Parenthesis
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Primary(ISerializationContext context, Parenthesis semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.PARENTHESIS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.PARENTHESIS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionExpressionParserRuleCall_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns UnaryMinus
	 *     ContractedIf returns UnaryMinus
	 *     ContractedIf.ContractedIf_1_0 returns UnaryMinus
	 *     Or returns UnaryMinus
	 *     Or.Or_1_0 returns UnaryMinus
	 *     And returns UnaryMinus
	 *     And.And_1_0 returns UnaryMinus
	 *     Equality returns UnaryMinus
	 *     Equality.Equality_1_0 returns UnaryMinus
	 *     Comparison returns UnaryMinus
	 *     Comparison.Comparison_1_0 returns UnaryMinus
	 *     PlusOrMinus returns UnaryMinus
	 *     PlusOrMinus.Plus_1_0_0_0 returns UnaryMinus
	 *     PlusOrMinus.Minus_1_0_1_0 returns UnaryMinus
	 *     MulOrDiv returns UnaryMinus
	 *     MulOrDiv.Mul_1_0_0_0 returns UnaryMinus
	 *     MulOrDiv.Div_1_0_1_0 returns UnaryMinus
	 *     Modulo returns UnaryMinus
	 *     Modulo.Modulo_1_0 returns UnaryMinus
	 *     Primary returns UnaryMinus
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, UnaryMinus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.UNARY_MINUS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.UNARY_MINUS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ArrayRef
	 *     ContractedIf returns ArrayRef
	 *     ContractedIf.ContractedIf_1_0 returns ArrayRef
	 *     Or returns ArrayRef
	 *     Or.Or_1_0 returns ArrayRef
	 *     And returns ArrayRef
	 *     And.And_1_0 returns ArrayRef
	 *     Equality returns ArrayRef
	 *     Equality.Equality_1_0 returns ArrayRef
	 *     Comparison returns ArrayRef
	 *     Comparison.Comparison_1_0 returns ArrayRef
	 *     PlusOrMinus returns ArrayRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns ArrayRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns ArrayRef
	 *     MulOrDiv returns ArrayRef
	 *     MulOrDiv.Mul_1_0_0_0 returns ArrayRef
	 *     MulOrDiv.Div_1_0_1_0 returns ArrayRef
	 *     Modulo returns ArrayRef
	 *     Modulo.Modulo_1_0 returns ArrayRef
	 *     Primary returns ArrayRef
	 *     Atomic returns ArrayRef
	 *     Ref returns ArrayRef
	 *     Ref.ArrayRef_1_0_0 returns ArrayRef
	 *     Ref.PropertyRef_1_1_0 returns ArrayRef
	 *
	 * Constraint:
	 *     (array=Ref_ArrayRef_1_0_0 indices+=Expression indices+=Expression*)
	 */
	protected void sequence_Ref(ISerializationContext context, ArrayRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PropertyRef
	 *     ContractedIf returns PropertyRef
	 *     ContractedIf.ContractedIf_1_0 returns PropertyRef
	 *     Or returns PropertyRef
	 *     Or.Or_1_0 returns PropertyRef
	 *     And returns PropertyRef
	 *     And.And_1_0 returns PropertyRef
	 *     Equality returns PropertyRef
	 *     Equality.Equality_1_0 returns PropertyRef
	 *     Comparison returns PropertyRef
	 *     Comparison.Comparison_1_0 returns PropertyRef
	 *     PlusOrMinus returns PropertyRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns PropertyRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns PropertyRef
	 *     MulOrDiv returns PropertyRef
	 *     MulOrDiv.Mul_1_0_0_0 returns PropertyRef
	 *     MulOrDiv.Div_1_0_1_0 returns PropertyRef
	 *     Modulo returns PropertyRef
	 *     Modulo.Modulo_1_0 returns PropertyRef
	 *     Primary returns PropertyRef
	 *     Atomic returns PropertyRef
	 *     Ref returns PropertyRef
	 *     Ref.ArrayRef_1_0_0 returns PropertyRef
	 *     Ref.PropertyRef_1_1_0 returns PropertyRef
	 *
	 * Constraint:
	 *     (object=Ref_PropertyRef_1_1_0 property=ID)
	 */
	protected void sequence_Ref(ISerializationContext context, PropertyRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.PROPERTY_REF__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.PROPERTY_REF__OBJECT));
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.PROPERTY_REF__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.PROPERTY_REF__PROPERTY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRefAccess().getPropertyRefObjectAction_1_1_0(), semanticObject.getObject());
		feeder.accept(grammarAccess.getRefAccess().getPropertyIDTerminalRuleCall_1_1_2_0(), semanticObject.getProperty());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SimpleVarRef
	 *     ContractedIf returns SimpleVarRef
	 *     ContractedIf.ContractedIf_1_0 returns SimpleVarRef
	 *     Or returns SimpleVarRef
	 *     Or.Or_1_0 returns SimpleVarRef
	 *     And returns SimpleVarRef
	 *     And.And_1_0 returns SimpleVarRef
	 *     Equality returns SimpleVarRef
	 *     Equality.Equality_1_0 returns SimpleVarRef
	 *     Comparison returns SimpleVarRef
	 *     Comparison.Comparison_1_0 returns SimpleVarRef
	 *     PlusOrMinus returns SimpleVarRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns SimpleVarRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns SimpleVarRef
	 *     MulOrDiv returns SimpleVarRef
	 *     MulOrDiv.Mul_1_0_0_0 returns SimpleVarRef
	 *     MulOrDiv.Div_1_0_1_0 returns SimpleVarRef
	 *     Modulo returns SimpleVarRef
	 *     Modulo.Modulo_1_0 returns SimpleVarRef
	 *     Primary returns SimpleVarRef
	 *     Atomic returns SimpleVarRef
	 *     Ref returns SimpleVarRef
	 *     Ref.ArrayRef_1_0_0 returns SimpleVarRef
	 *     Ref.PropertyRef_1_1_0 returns SimpleVarRef
	 *     SimpleVarRef returns SimpleVarRef
	 *
	 * Constraint:
	 *     target=ID
	 */
	protected void sequence_SimpleVarRef(ISerializationContext context, SimpleVarRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniExprPackage.Literals.SIMPLE_VAR_REF__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniExprPackage.Literals.SIMPLE_VAR_REF__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleVarRefAccess().getTargetIDTerminalRuleCall_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
}
